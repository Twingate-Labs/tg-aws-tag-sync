AWSTemplateFormatVersion: 2010-09-09
Parameters:
  TwingateApiKey:
    Type: String
    Default: Insert Twingate API Key Here
  TwingateNetworkAddress:
    Type: String
    Default: Insert Twingate Network Address Here
Resources:
  TwingateAPIKeyParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Description: Twingate API Key
      Name: TwingateApiKey
      Type: String
      Value: !Ref TwingateApiKey
  TwingateNetworkAddressParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Description: Twingate Network Address
      Name: TwingateNetworkAddress
      Type: String
      Value: !Ref TwingateNetworkAddress
  TwingateRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Description: TwingateRole
      Policies:
        - PolicyName: EmbeddedInlinePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "ec2:DeleteTags"
                  - "ec2:CreateTags"
                  - "ec2:Describe*"
                  - "ecs:TagResource"
                  - "ecs:UntagResource"
                  - "ecs:Describe*"
                  - "rds:AddTagsToResource"
                  - "rds:RemoveTagsFromResource"
                  - "rds:Describe*"
                Resource: '*'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMReadOnlyAccess
        - arn:aws:iam::aws:policy/ResourceGroupsandTagEditorFullAccess
        - arn:aws:iam::aws:policy/AWSLambdaExecute
        - arn:aws:iam::aws:policy/CloudWatchLogsFullAccess
      RoleName: !Join ["-", ["TwingateRole", !Ref "AWS::Region"]]
  LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Architectures:
        - x86_64
      Code:
        ZipFile: |
          import{EC2Client as e,DescribeInstancesCommand as r}from"@aws-sdk/client-ec2";import{ECSClient as t,DescribeTasksCommand as s}from"@aws-sdk/client-ecs";import{RDSClient as o,DescribeDBInstancesCommand as n}from"@aws-sdk/client-rds";import{SSMClient as a,GetParametersCommand as i}from"@aws-sdk/client-ssm";import{ResourceGroupsTaggingAPIClient as d,TagResourcesCommand as u,UntagResourcesCommand as l}from"@aws-sdk/client-resource-groups-tagging-api";const c=e=>`${e[0].toUpperCase()}${e.slice(1)}`,p=async e=>new Promise((r=>setTimeout(r,e)));class m{static VERSION="0.1.0";static FieldSet={ID:"ID",LABEL:"LABEL",CONNECTIONS:"CONNECTIONS",NODES:"NODES",ALL:"ALL"};static IdPrefixes={RemoteNetwork:"UmVtb3RlTmV0d29yazo",Group:"R3JvdXA6",Resource:"UmVzb3Vy",User:"VXNlcjox"};static Schema={ResourceAddress:{isNode:!1,fields:[{name:"type",type:"enum",typeName:"AddressType",valueMap:{IP:"IP",DNS:"DNS"}},{name:"value",type:"string"}]},ResourceProtocols:{isNode:!1,fields:[{name:"allowIcmp",type:"boolean"},{name:"tcp",type:"Object",typeName:"ResourceProtocol"},{name:"udp",type:"Object",typeName:"ResourceProtocol"}]},ResourceProtocol:{isNode:!1,fields:[{name:"policy",type:"enum",typeName:"ProtocolPolicy",valueMap:{ALLOW_ALL:"Allow All",RESTRICTED:"Restricted"}},{name:"ports",type:"Object",multiple:!0,typeName:"PortRange",flattenStatementsFn:(e,r)=>[`obj["${e.map(((e,r)=>0===r?e:c(e))).join("")}"] = obj.${e.join(".")}.map(port => (port.start === port.end ? port.start : \`\${port.start}-\${port.end}\`)).join(", ");`]}]},PortRange:{isNode:!1,fields:[{name:"start",type:"integer"},{name:"end",type:"integer"}]},Key:{isNode:!1,fields:[{name:"totalCount",type:"integer"}]},User:{isNode:!0,fields:[{name:"createdAt",type:"datetime"},{name:"updatedAt",type:"datetime"},{name:"firstName",type:"string"},{name:"lastName",type:"string"},{name:"email",type:"string",isLabel:!0},{name:"avatarUrl",type:"string"},{name:"isAdmin",type:"boolean"},{name:"state",type:"enum",typeName:"UserState",valueMap:{PENDING:"Pending",ACTIVE:"Active",DISABLED:"Disabled"}},{name:"groups",type:"Connection",typeName:"Group"}]},Group:{isNode:!0,canCreate:!0,fields:[{name:"createdAt",type:"datetime"},{name:"updatedAt",type:"datetime"},{name:"name",type:"string",isLabel:!0},{name:"isActive",type:"boolean"},{name:"type",type:"enum",typeName:"GroupType",valueMap:{MANUAL:"Manual",SYNCED:"Synced",SYSTEM:"System"}},{name:"users",type:"Connection",typeName:"User"},{name:"resources",type:"Connection",typeName:"Resource"}]},Resource:{isNode:!0,canCreate:!0,fields:[{name:"name",type:"string",isLabel:!0,canQuery:!0},{name:"createdAt",type:"datetime"},{name:"updatedAt",type:"datetime"},{name:"isActive",type:"boolean"},{name:"address",type:"Object",typeName:"ResourceAddress"},{name:"protocols",type:"Object",typeName:"ResourceProtocols"},{name:"remoteNetwork",type:"Node",typeName:"RemoteNetwork"},{name:"groups",type:"Connection",typeName:"Group"}]},RemoteNetwork:{isNode:!0,canCreate:!0,queryNodeField:"remoteNetwork",queryConnectionField:"remoteNetworks",fields:[{name:"name",type:"string",isLabel:!0},{name:"isActive",type:"boolean"},{name:"createdAt",type:"datetime"},{name:"updatedAt",type:"datetime"},{name:"resources",type:"Connection",typeName:"Resource"},{name:"connectors",type:"Connection",typeName:"Connector"}]},Connector:{isNode:!0,fields:[{name:"name",type:"string",isLabel:!0},{name:"createdAt",type:"datetime"},{name:"updatedAt",type:"datetime"},{name:"lastHeartbeatAt",type:"datetime"},{name:"state",type:"enum",typeName:"ConnectorState",valueMap:{ALIVE:"Online",DEAD_NO_HEARTBEAT:"Offline - No Heartbeat",DEAD_HEARTBEAT_TOO_OLD:"Offline - Heartbeat too old",DEAD_NO_RELAYS:"Offline - No relays"}},{name:"remoteNetwork",type:"Node",typeName:"RemoteNetwork"}]},Device:{isNode:!0,fields:[{name:"name",type:"string",isLabel:!0},{name:"user",type:"Node",typeName:"User"},{name:"isTrusted",type:"boolean"},{name:"lastConnectedAt",type:"datetime"},{name:"lastFailedLoginAt",type:"datetime"},{name:"lastSuccessfulLoginAt",type:"datetime"},{name:"deviceType",type:"enum",typeName:"DeviceType",valueMap:{GENERIC:"Generic",DESKTOP:"Desktop",LAPTOP:"Laptop",TABLET:"Tablet",MOBILE:"Mobile"}},{name:"osName",type:"enum",typeName:"DeviceOsName",valueMap:{IOS:"iOS",MAC_OS:"MacOS",ANDROID:"Android",CHROME_OS:"chromeOS",WINDOWS:"Windows",LINUX:"Linux"}},{name:"osVersion",type:"string"},{name:"clientVersion",type:"string"},{name:"hardwareModel",type:"string"},{name:"hostname",type:"string"},{name:"username",type:"string"},{name:"serialNumber",type:"string"},{name:"manufacturerName",type:"string"}]},ServiceAccount:{isNode:!0,queryNodeField:"serviceAccount",queryConnectionField:"serviceAccounts",fields:[{name:"name",type:"string",isLabel:!0},{name:"createdAt",type:"datetime"},{name:"updatedAt",type:"datetime"},{name:"resources",type:"Connection",typeName:"Resource"},{name:"keys",type:"Object",typeName:"Key"}]}};constructor(e,r,t={}){const s=e.indexOf(".");t=t||{},-1!==s&&(t.domain=e.substring(s+1),e=e.substring(0,s));const o={domain:"twingate.com",endpoint:"api/graphql/",defaultRequestOptions:{method:"POST"},defaultRequestHeaders:{"Content-Type":"application/json",Accept:"application/json"},onApiError:null,logger:console,silenceApiErrorsWithResults:!1,defaultPageSize:0,applicationName:`tg-aws-tag-sync/${m.VERSION}`},{domain:n,endpoint:a,defaultRequestOptions:i,defaultRequestHeaders:d,onApiError:u,logger:l,silenceApiErrorsWithResults:c,defaultPageSize:p,applicationName:g}=Object.assign(o,t);this.networkName=e,this.apiKey=r,this.domain=n,this.endpoint=a,this.defaultPageSize=p,this.defaultRequestOptions=i,void 0===d["User-Agent"]&&(d["User-Agent"]=g),this.defaultRequestHeaders=d,this.onApiError=u,this.logger=l,this.silenceApiErrorsWithResults=c}async handleApiError(e,r,t){if("function"==typeof this.onApiError)return await this.onApiError(this.networkName,e,r,t);if(null!=t.data){let r=t.data&&t.data.result&&Array.isArray(t.data.result.edges);return r&&this.silenceApiErrorsWithResults||console.warn(`API Error on '${this.networkName}' for query: '${e}'. Errors: ${JSON.stringify(t.errors)}`),r&&(t.data.result.edges=t.data.result.edges.filter((e=>null!=e&&null!=e.node))),t.data}throw new Error(`API Error on '${this.networkName}' for query: '${e}'. Errors: ${JSON.stringify(t.errors)}`)}async exec(e,r={}){const t=`https://${this.networkName}.${this.domain}/${this.endpoint}`,s=JSON.stringify({query:e,variables:r});let o=!0,n=null;for(;o;)if(n=await fetch(t,{...this.defaultRequestOptions,headers:{...this.defaultRequestHeaders,"X-API-KEY":this.apiKey},body:s}),429===n.status){let e=parseInt(n.headers.get("retry-after"))||60;console.warn(`Request is throttled (429), retrying in: ${e} seconds. Query: ${s}`),await p(1e3*e)}else{if(n.status<200||n.status>299)throw new Error(`API returned status: ${n.status}. Query: ${s}`);o=!1}let a=await n.json();return Array.isArray(a.errors)&&a.errors.length>0?await this.handleApiError(e,r,a):a.data}getRootConnectionPagedQuery(e,r,t,s="result",o=0){const n=o>0?`first:${o},`:"";return s=null!=s&&s!=r?`${s}:`:"",Array.isArray(t)&&(t=t.join(" ")),`query ${e}($endCursor:String){${s}${r}(${n}after:$endCursor){pageInfo{hasNextPage endCursor}edges{node{${t}}}}}`}getRootNodePagedQuery(e,r,t,s="id",o="result",n=0){const a=n>0?`first:${n},`:"";return o=null!=o&&o!=r?`${o}:`:"",Array.isArray(s)&&(s=s.join(" ")),`query ${e}($id:ID!,$endCursor:String){${o}${r}(id:$id){${t}(${a}after:$endCursor){pageInfo{hasNextPage endCursor}edges{node{${s}}}}}}`}getRootNodeQuery(e,r,t,s="result"){return s=null!=s&&s!=r?`${s}:`:"",Array.isArray(t)&&(t=t.join(" ")),`query ${e}($id:ID!){${s}${r}(id:$id){${t}}}`}getTopLevelKVQuery(e,r,t,s,o="result",n=0,a="key",i="value"){return this.getRootConnectionPagedQuery(e,r,`${i}:${s} ${a}:${t}`,o,n)}async fetchAllPages(e,r={}){const t=(r=r||{}).getResultObjFn||(e=>e.result),s={initialValue:[],recordTransformFn:(e,r)=>e,pageTransformFn:(e,r,s,o)=>{let n=t(e).edges.map((e=>s(e.node,o)));return Array.isArray(r)&&r.push(...n),n},nextPageFn:e=>t(e).pageInfo,onPageFn:e=>e,pageInfo:{hasNextPage:!0,endCursor:null},recordTransformOpts:{},id:void 0};let o,{initialValue:n,recordTransformFn:a,pageTransformFn:i,nextPageFn:d,onPageFn:u,pageInfo:l,recordTransformOpts:c,id:p}=Object.assign(s,r),m=n,g=null;for(;!0===l.hasNextPage;)o=await this.exec(e,{id:p,endCursor:l.endCursor}),g=i(o,m,a,c),u(g),l=d(o);return m}async fetchAllRootNodePages(e,r){const t=(r=r||{}).getResultObjFn||(e=>e.result),s={initialValue:[],recordTransformFn:(e,r)=>e,pageTransformFn:(e,r,s,o)=>{let n=t(e).edges.map((e=>s(e.node,o)));return Array.isArray(r)&&r.push(...n),n},nextPageFn:e=>t(e).pageInfo,onPageFn:e=>e,pageInfo:{hasNextPage:!0,endCursor:null},recordTransformOpts:{},id:void 0};let o,{initialValue:n,recordTransformFn:a,pageTransformFn:i,nextPageFn:d,onPageFn:u,pageInfo:l,recordTransformOpts:c,id:p}=Object.assign(s,r),m=n,g=null,y="";for(;!0===l.hasNextPage;){if(o=await this.exec(e,{id:p,endCursor:l.endCursor}),1!=Object.keys(o.result).length)throw new Error("Number of Connection Fields Cannot Be More Than 1.");y=Object.keys(o.result)[0],g=i({result:o.result[y]},m,a,c),u(g),l=d({result:o.result[y]})}return m}_processFetchOptions(e,r,t){const s=m.Schema[e];if(null==s)throw new Error(`Cannot find schema for type: ${e}`);let o=Object.assign({},r);o.fieldSet=o.fieldSet||[m.FieldSet.ALL];const n=Object.assign({},o.fieldOpts);for(const e of[...s.connectionFields,...s.nodeFields]){n[e]=n[e]||{};let r=o.defaultConnectionFields||"id";n[e].joinConnectionFields=n[e].joinConnectionFields||o.joinConnectionFields,"LABEL_FIELD"===r&&(r=m.Schema[s.fieldsByName[e].typeName].labelField),n[e].nodeFields=n[e].nodeFields||r,null==n[e].nodeFieldMapFn&&(Array.isArray(n[e].nodeFields)?n[e].nodeFieldMapFn=e=>e:n[e].nodeFieldMapFn=new Function("node",`return node.${n[e].nodeFields};`)),null==n[e].nodeQuery&&(n[e].nodeQuery=this.getRootNodePagedQuery(s.nodeQueryName,s.queryNodeField,e,n[e].nodeFields,"result",this.defaultPageSize)),n[e].getResultObjFn=n[e].getResultObjFn||new Function("response",`return response.result.${e}`)}return{opts:o,fieldOpts:n,nodeSchema:s}}async _processFetchConnections(e,r,t){for(const s of e.connectionFields){let e=r[s];if(null==t[s])continue;let o=t[s].pageInfo,n=t[s].edges.map((e=>e.node));null!=o&&!0===o.hasNextPage&&n.push(...await this.fetchAllPages(e.nodeQuery,{id:t.id,pageInfo:o,getResultObjFn:e.getResultObjFn})),t[s]=n.map(e.nodeFieldMapFn),"function"==typeof e.joinConnectionFields&&(t[s]=e.joinConnectionFields(t[s]))}}async _fetchAllNodesOfType(e,r){let{opts:t,fieldOpts:s,nodeSchema:o}=this._processFetchOptions(e,r,"All");const n=this._getFields(e,t.fieldSet,s),a=o.recordTransformFn,i=t.recordTransformOpts||{},d=this.getRootConnectionPagedQuery(`All${e}s`,o.queryConnectionField,n,"result",this.defaultPageSize);let u=await this.fetchAllPages(d,{recordTransformFn:a,recordTransformOpts:i});for(const e of u)await this._processFetchConnections(o,s,e);return u}async _fetchNodesOfTypeById(e,r,t){let{opts:s,fieldOpts:o,nodeSchema:n}=this._processFetchOptions(e,t,"All");const a=this._getFields(e,s.fieldSet,o),i=n.recordTransformFn,d=s.recordTransformOpts||{},u=this.getRootNodeQuery(`${e}ById`,n.queryNodeField,a,"result");let l=await this.fetchAllPages(u,{initialValue:{},recordTransformFn:i,recordTransformOpts:d,nextPageFn:()=>({hasNextPage:!1}),pageTransformFn:(e,r,t,s)=>Object.assign(r,t(e.result,s)),id:r});return await this._processFetchConnections(n,o,l),l}async fetchAll(e){let r={},t=(e=e||{}).typesToFetch||Object.values(m.Schema).filter((e=>e.isNode)).map((e=>e.name)),s=t.map((r=>this._fetchAllNodesOfType(r,e))),o=await Promise.all(s);for(let e=0;e<t.length;e++)r[t[e]]=o[e];return r}async fetchAllConnectors(e){return this._fetchAllNodesOfType("Connector",e)}async fetchAllDevices(e){return this._fetchAllNodesOfType("Device",e)}async fetchAllServiceAccounts(e){return this._fetchAllNodesOfType("ServiceAccount",e)}async fetchAllUsers(e){return this._fetchAllNodesOfType("User",e)}async fetchAllResources(e){return this._fetchAllNodesOfType("Resource",e)}async fetchAllRemoteNetworks(e){return this._fetchAllNodesOfType("RemoteNetwork",e)}async fetchAllGroups(e){return this._fetchAllNodesOfType("Group",e)}async fetchConnectorById(e,r){return this._fetchNodesOfTypeById("Connector",e,r)}async fetchDeviceById(e,r){return this._fetchNodesOfTypeById("Device",e,r)}async fetchUserById(e,r){return this._fetchNodesOfTypeById("User",e,r)}async fetchResourceById(e,r){return this._fetchNodesOfTypeById("Resource",e,r)}async fetchRemoteNetworkById(e,r){return this._fetchNodesOfTypeById("RemoteNetwork",e,r)}async fetchGroupById(e,r){return this._fetchNodesOfTypeById("Group",e,r)}_getFields(e,r=[m.FieldSet.ALL],t={}){const s=m.Schema[e],o=s.fields;let n=e=>!0!==e.ignore;if("function"==typeof r);else if(!r.includes(m.FieldSet.ALL)){let e=t.extraFields||[];r.includes(m.FieldSet.ID)&&e.push("id"),r.includes(m.FieldSet.LABEL)&&e.push(s.labelField),r.includes(m.FieldSet.CONNECTIONS)&&e.push(...s.connectionFields),r.includes(m.FieldSet.NODES)&&e.push(...s.nodeFields),n=r=>e.includes(r.name)}t=t||{};return o.map((e=>Object.assign({},e,t[e.name]))).filter(n).map((e=>{switch(e.type){case"Object":return`${e.name}{${e.nodeFields||this._getFields(e.typeName,e.fieldSet,e.fieldOptions)}}`;case"Node":return`${e.name}{${e.nodeFields||this._getFields(e.typeName,e.fieldSet||r,e.fieldOptions)}}`;case"Connection":return`${e.name}{pageInfo{hasNextPage endCursor}edges{node{${e.nodeFields||"id"}}}}`;default:return e.name}})).join(" ")}async addUserToGroup(e,r){let t=Array.isArray(r)?r:[r];return(await this.exec("mutation AddUserToGroup($groupId:ID!,$userIds:[ID]){groupUpdate(id:$groupId,addedUserIds:$userIds){error entity{id name users{edges{node{id email}}}}}}",{groupId:e,userIds:t})).groupUpdate.entity}async addResourceToServiceAccount(e,r){let t=Array.isArray(r)?r:[r];return(await this.exec("mutation AddResourceToServiceAccount($serviceAccountId:ID!,$resourceIds:[ID]){serviceAccountUpdate(id:$serviceAccountId,addedResourceIds:$resourceIds){error entity{id name resources{edges{node{id name}}}}}}",{serviceAccountId:e,resourceIds:t})).serviceAccountUpdate.entity}async addGroupToResource(e,r){return(await this.exec("mutation AddGroupToResource($resourceId:ID!,$groupIds:[ID]){resourceUpdate(id:$resourceId,addedGroupIds:$groupIds){error entity{id name groups{edges{node{id name}}}}}}",{resourceId:e,groupIds:r})).resourceUpdate.entity}async addResourceToGroup(e,r){return(await this.exec("mutation AddResourceToGroup($groupId:ID!,$resourceIds:[ID]){groupUpdate(id:$groupId,addedResourceIds:$resourceIds){error entity{id name resources{edges{node{id name}}}}}}",{groupId:e,resourceIds:r})).groupUpdate.entity}async removeUserFromGroup(e,r){let t=Array.isArray(r)?r:[r];return(await this.exec("mutation RemoveUserFromGroup($groupId:ID!,$userIds:[ID]){groupUpdate(id:$groupId,removedUserIds:$userIds){error entity{id name users{edges{node{id email}}}}}}",{groupId:e,userIds:t})).groupUpdate.entity}async removeGroupFromResource(e,r){let t=Array.isArray(r)?r:[r];return(await this.exec("mutation RemoveGroupFromResource($resourceId:ID!,$groupIds:[ID]){resourceUpdate(id:$resourceId,removedGroupIds:$groupIds){error entity{id name groups{edges{node{id name}}}}}}",{resourceId:e,groupIds:t})).resourceUpdate.entity}async removeResourceFromGroup(e,r){let t=Array.isArray(r)?r:[r];return(await this.exec("mutation RemoveResourceFromGroup($groupId:ID!,$resourceIds:[ID]){groupUpdate(id:$groupId,removedResourceIds:$resourceIds){error entity{id name resources{edges{node{id name}}}}}}",{groupId:e,resourceIds:t})).groupUpdate.entity}async setGroupUsersAndResources(e,r,t){let s=["$groupId:ID!"],o=["id:$groupId"];null!=r&&(s.push("$userIds:[ID]"),o.push("userIds:$userIds")),null!=t&&(s.push("$resourceIds:[ID]"),o.push("resourceIds:$resourceIds"));const n=`mutation SetGroupUsersAndResources(${s.join(",")}){result:groupUpdate(${o.join(",")}){ok error}}`;return(await this.exec(n,{groupId:e,userIds:r,resourceIds:t})).result}async loadCompleteGroup(e){let r=this.networkName,t=this.apiKey;let s=await this.exec("query Groups($name:String){groups(filter:{name:{eq:$name}}){edges{node{id name users{pageInfo{hasNextPage endCursor}edges{node{id}}}resources{pageInfo{hasNextPage endCursor}edges{node{id}}}}}}}",{name:e}),o=s.groups.edges.length;if(1!==o)return void console.warn(`Searching for group with name '${e}' returned ${o} results.`);let n=s.groups.edges[0].node,a=n.users.pageInfo;n.userIds=n.users.edges.map((e=>e.node.id));let i=n.resources.pageInfo;for(n.resourceIds=n.resources.edges.map((e=>e.node.id));!0===a.hasNextPage;){let e=await loadGroupUsers(r,t,n.id,a.endCursor);n.userIds.push(...e.ids),a=e.pageInfo}for(;!0===i.hasNextPage;){let e=await loadGroupResources(r,t,n.id,i.endCursor);n.resourceIds.push(...e.ids),i=e.pageInfo}return n}async lookupRemoteNetworkByName(e){let r=(await this.exec("query RemoteNetworkByName($name:String){remoteNetworks(filter:{name:{eq:$name}}){edges{node{id}}}}",{name:""+e.trim()})).remoteNetworks;return null==r||null==r.edges||r.edges.length<1?null:r.edges[0].node.id}async lookupGroupByName(e){let r=(await this.exec("query GroupByName($name:String){groups(filter:{name:{eq:$name}}){edges{node{id}}}}",{name:""+e.trim()})).groups;return null==r||null==r.edges||r.edges.length<1?null:r.edges[0].node.id}async lookupUserByEmail(e){let r=(await this.exec("query UserByEmail($email:String){users(filter:{email:{eq:$email}}){edges{node{id}}}}",{email:""+e.trim()})).users;return null==r||null==r.edges||r.edges.length<1?null:r.edges[0].node.id}async lookupResourceByName(e){let r=(await this.exec("query ResourceByName($name:String){resources(filter:{name:{eq:$name}}){edges{node{id}}}}",{name:""+e.trim()})).resources;return null==r||null==r.edges||r.edges.length<1?null:r.edges[0].node.id}async setDeviceTrust(e,r){let t=await this.exec("mutation SetDeviceTrust($id:ID!,$isTrusted:Boolean!){result:deviceUpdate(id:$id,isTrusted:$isTrusted){ok error entity{id isTrusted}}}",{id:e,isTrusted:r});if(null!==t.result.error)throw new Error(`Error setting device trust: '${t.result.error}'`);return t.result.entity}async createGroup(e,r=[],t=[]){let s=await this.exec("mutation CreateGroup($name:String!,$resourceIds:[ID],$userIds:[ID]){result:groupCreate(name:$name,resourceIds:$resourceIds,userIds:$userIds){error entity{id name users{edges{node{id email}}}}}}",{name:e,resourceIds:r,userIds:t});if(null!==s.result.error)throw new Error(`Error creating group: '${s.result.error}'`);return s.result.entity}async createRemoteNetwork(e){let r=await this.exec("mutation CreateRemoteNetwork($name:String!){result:remoteNetworkCreate(name:$name){error entity{id}}}",{name:e});if(null!==r.result.error)throw new Error(`Error creating remote network: '${r.result.error}'`);return r.result.entity}async createServiceAccount(e,r=[]){let t=await this.exec("mutation CreateServiceAccount($name:String!,$resourceIds:[ID]){result:serviceAccountCreate(name:$name,resourceIds:$resourceIds){error entity{id name resources{edges{node{id name}}}}}}",{name:e,resourceIds:r});if(null!==t.result.error)throw new Error(`Error creating service account: '${t.result.error}'`);return t.result.entity}async updateRemoteNetwork(e,r=null,t=null){let s={id:e},o=["$id:ID"],n=["id:$id"];!0!==r&&!1!==r||(s.isActive=r,o.push("$isActive:Boolean"),n.push("isActive:$isActive")),"string"==typeof t&&(s.name=t,o.push("$name:String"),n.push("name:$name"));const a=`mutation UpdateRemoteNetwork(${o.join(",")}){result:remoteNetworkUpdate(${n.join(",")}){ok error entity{id}}}`;let i=await this.exec(a,s);if(null!==i.result.error)throw new Error(`Error updating remote network: '${i.result.error}'`);return i.result.entity}async createConnector(e){let r=await this.exec("mutation CreateConnector($remoteNetworkId:ID!){result:connectorCreate(remoteNetworkId:$remoteNetworkId){error entity{id name remoteNetwork{name}}}}",{remoteNetworkId:e});if(null!==r.result.error)throw new Error(`Error creating connector: '${r.result.error}'`);return r.result.entity}async setConnectorName(e,r){let t=await this.exec("mutation SetConnectorName($id:ID!,$name:String){result:connectorUpdate(id:$id,name:$name){error entity{id name}}}",{id:e,name:r});if(null!==t.result.error)throw new Error(`Error setting connector name: '${t.result.error}'`);return t.result.entity}async generateConnectorTokens(e){let r=await this.exec("mutation GenerateTokens($connectorId:ID!){result:connectorGenerateTokens(connectorId:$connectorId){error ok connectorTokens{accessToken refreshToken}}}",{connectorId:e});if(null!==r.result.error)throw new Error(`Error setting connector name: '${r.result.error}'`);return r.result.connectorTokens}async serviceAccountKeyCreate(e,r,t){let s=await this.exec("mutation CreateKey($serviceAccountId:ID!, $name:String,$expirationTime:Int!){result:serviceAccountKeyCreate(serviceAccountId:$serviceAccountId,name:$name,expirationTime:$expirationTime){error token entity{id name serviceAccount{id name}}}}",{serviceAccountId:e,name:r,expirationTime:t});if(null!==s.result.error)throw new Error(`Error creating service account key: '${s.result.error}'`);return s.result}async createResource(e,r,t,s=null,o=[]){let n=await this.exec("mutation CreateResource($name:String!,$address:String!,$remoteNetworkId:ID!,$protocols:ProtocolsInput,$groupIds:[ID]){result:resourceCreate(address:$address,groupIds:$groupIds,name:$name,protocols:$protocols,remoteNetworkId:$remoteNetworkId){error entity{id name address{value} remoteNetwork{name} groups{edges{node{id name}}}}}}",{name:e,address:r,remoteNetworkId:t,protocols:s,groupIds:o});if(null!==n.result.error)throw new Error(`Error creating resource: '${n.result.error}'`);return n.result.entity}async removeGroup(e){let r=await this.exec("mutation RemoveGroup($id:ID!){result:groupDelete(id:$id){ok, error}}",{id:e});if(!r.result.ok)throw new Error(`Error removing group '${e}' ${r.result.error}`);return!0}async removeRemoteNetwork(e){let r=await this.exec("mutation RemoveRemoteNetwork($id:ID!){result:remoteNetworkDelete(id:$id){ok, error}}",{id:e});if(!r.result.ok)throw new Error(`Error removing remote network '${e}' ${r.result.error}`);return!0}async removeResource(e){let r=await this.exec("mutation RemoveResource($id:ID!){result:resourceDelete(id:$id){ok, error}}",{id:e});if(!r.result.ok)throw new Error(`Error removing resource '${e}' ${r.result.error}`);return!0}async removeServiceAccount(e){let r=await this.exec("mutation RemoveServiceAccount($id:ID!){result:serviceAccountDelete(id:$id){ok, error}}",{id:e});if(!r.result.ok)throw new Error(`Error removing group '${e}' ${r.result.error}`);return!0}async setDeviceTrustBulk(e,r=(e=>e.id),t=(e=>e.isTrusted)){if(!Array.isArray(e))throw new Error("setDeviceTrustBulk requires an array as input.");if(0===e.length)return[];if(!e.every((e=>"string"==typeof e.id&&"boolean"==typeof e.isTrusted)))throw new Error("setDeviceTrustBulk requires every item to have an 'id' (string) and 'isTrusted' (boolean) value");const s=e.map(((e,r)=>`$id${r}:ID!,$isTrusted${r}:Boolean!`)).join(","),o=e.map(((e,r)=>`result${r}:deviceUpdate(id:$id${r},isTrusted:$isTrusted${r}){ok error entity{id isTrusted}}`)).join(" "),n=Object.fromEntries(e.flatMap(((e,s)=>[[`id${s}`,r(e)],[`isTrusted${s}`,t(e)]])));let a=`mutation BulkSetDeviceTrust${e.length}(${s}){${o}}`,i=await this.exec(a,n),d=[];for(let r=0;r<e.length;r++)d.push(i[`result${r}`]);return d}async removeGroupsBulk(e){if(!Array.isArray(e))throw new Error("removeGroupsBulk requires an array as input.");if(0===e.length)return[];if(!e.every((e=>"string"==typeof e&&e.startsWith(m.IdPrefixes.Group))))throw new Error("removeGroupsBulk requires every value to be a Group Id");for(let r=0;r<e.length;r++)try{await this.removeGroup(e[r])}catch(e){console.error(e)}return!0}async removeRemoteNetworksBulk(e){let r=await this.exec("mutation RemoveRemoteNetwork($id:ID!){result:remoteNetworkDelete(id:$id){ok, error}}",{id:id});if(!r.result.ok)throw new Error(`Error removing remote network '${id}' ${r.result.error}`);return!0}async removeResourcesBulk(e){let r=await this.exec("mutation RemoveResource($ids:ID!){result:resourceDelete(id:$ids){ok, error}}",{ids:e});if(!r.result.ok)throw new Error(`Error removing resource '${e}' ${r.result.error}`);return!0}static async testNetworkValid(e){let r=-1===e.indexOf(".")?`https://${e}.twingate.com/api/graphql/?testNetworkValid`:`https://${e}/api/graphql/?testNetworkValid`;return 404!==(await fetch(r)).status}static async testApiKeyValid(e,r){let t=-1===e.indexOf(".")?`https://${e}.twingate.com/api/graphql/?testApiKeyValid`:`https://${e}/api/graphql/?testApiKeyValid`;return 401!==(await fetch(t,{headers:{"X-API-KEY":r}})).status}}!function(){try{for(const[e,r]of Object.entries(m.Schema)){r.name=e,r.fieldsByName={},r.fields.reduce(((e,r)=>(e[r.name]=r,e)),r.fieldsByName),r.dateTimeFields=r.fields.filter((e=>"datetime"===e.type)).map((e=>e.name)),r.enumFields=r.fields.filter((e=>"enum"===e.type)).map((e=>e.name)),r.connectionFields=r.fields.filter((e=>"Connection"===e.type)).map((e=>e.name)),r.nodeFields=r.fields.filter((e=>"Node"===e.type)).map((e=>e.name)),r.objectFields=r.fields.filter((e=>"Object"===e.type)).map((e=>e.name));const t=r.fields.filter((e=>!0===e.isLabel));if(1===t.length&&(r.labelField=t[0].name),!0===r.isNode){r.fields.unshift({name:"id",type:"string",primaryKey:!0}),r.queryNodeField=r.queryNodeField||e.toLowerCase(),r.nodeQueryName=r.nodeQueryName||`Query${e}`,r.queryConnectionField=r.queryConnectionField||`${r.queryNodeField}s`;let t=r.fields.filter((e=>e.isLabel));1===t.length?r.labelField=t[0].name:console.warn(`No label field found for type '${e}'!`)}}const e=(r,t)=>{Array.isArray(r)||(r=[r]);let s=m.Schema[t.typeName],o=[];for(let t of s.fields){let s=[...r,t.name],n=t.flattenStatementsFn?t.flattenStatementsFn:e;if("Object"===t.type)o.push(...n(s,t));else{let e=s.map(((e,r)=>0===r?e:c(e)));o.push(`obj["${e.join("")}"] = obj.${s.join(".")};`)}}return o};for(const[r,t]of Object.entries(m.Schema)){let r=["opts = opts || {mapDateFields: true};"];r.push("if ( opts.mapEnumToDisplay === true ) {"),r.push(...t.enumFields.map((e=>`    if ( obj["${e}"] != undefined ) { let vm = ${JSON.stringify(t.fieldsByName[e].valueMap)}; obj["${e}"] = vm[obj["${e}"]];}`))),r.push("}"),r.push("if ( opts.mapDateFields === true ) {"),r.push(...t.dateTimeFields.map((e=>`    if ( obj["${e}"] != undefined ) obj["${e}"] = new Date(obj["${e}"]);`))),r.push("}"),r.push("if ( opts.mapNodeToId === true ) {"),r.push(...t.nodeFields.map((e=>`    if ( obj["${e}"] != undefined ) obj["${e}Id"] = obj["${e}"].id;`))),r.push("}"),r.push("if ( opts.mapNodeToLabel === true ) {"),r.push(...t.nodeFields.map((e=>`    if ( obj["${e}"] != undefined ) obj["${e}Label"] = obj["${e}"].${m.Schema[t.fieldsByName[e].typeName].labelField};`))),r.push("}"),r.push("if ( opts.mapNodeToLabel || opts.mapNodeToId ) {"),r.push(...t.nodeFields.map((e=>`    delete obj["${e}"];`))),r.push("}"),r.push("if ( opts.flattenObjectFields === true ) {");for(const s of t.objectFields)r.push(`    if ( obj["${s}"] !== undefined ) {`),r.push(...e(s,t.fieldsByName[s]).map((e=>`        ${e}`))),r.push(`        delete obj["${s}"];`),r.push("    }");r.push("}"),r.push("return obj;"),t.recordTransformFn=new Function("obj","opts={}",r.join("\r\n"))}}catch(e){console.error(`Problem pre-processing schema: ${e.stack}`)}}();const g=new a,y=new i({Names:["TwingateApiKey","TwingateNetworkAddress"],WithDecryption:!0}),f=await g.send(y),h=f.Parameters.find((e=>"TwingateNetworkAddress"===e.Name)).Value,$=f.Parameters.find((e=>"TwingateApiKey"===e.Name)).Value;async function w(a){let[i,c,p,g,y]=["","","",""];if("rds"==a.detail.service&&"cluster"==a.detail["resource-type"])throw new Error("RDS cluster is not supported");if(a.detail["changed-tag-keys"].includes("tg_groups")&&"tg_groups"in a.detail.tags&&!("tg_resource"in a.detail.tags)&&!a.detail["changed-tag-keys"].includes("tg_resource"))throw new Error("tg_resource tag is not found, cannot add groups");if("tg_resource"in a.detail.tags)if(y=a.detail.tags.tg_resource.replace(/\s*\+\+\s*/g,"++").split("++"),3==y.length)[i,c,p]=y;else{console.log("Twingate resource name and/or address is not found in the AWS tag 'tg_resource', trying to populate them using AWS resource name and resource private Ip"),i=y[0];let d=a.resources[0].split("/")[a.resources[0].split("/").length-1],u=a.detail.service+a.detail["resource-type"],l=await async function(a,i,d){let[u,l]=["",""];switch(i){case"ec2instance":const c={InstanceIds:[a]},p=new e,m=new r(c),g=await p.send(m);l=g.Reservations[0].Instances[0].PrivateIpAddress;try{u=g.Reservations[0].Instances[0].Tags.filter((e=>"Name".includes(e.Key)))[0].Value}catch(e){u=l,1==d&&console.log(`Instance Name not found, using instance IP '${l}' as the resource name`)}break;case"ecstask":const y={tasks:[a]},f=new t,h=new s(y),$=await f.send(h);l=$.tasks[0].attachments[0].details.filter((e=>"privateIPv4Address".includes(e.name)))[0].value,u=`${$.tasks[0].group} - ${$.tasks[0].taskDefinitionArn.split("/")[$.tasks[0].taskDefinitionArn.split("/").length-1]} - ${l}`;break;case"rdsdb":const w={DBInstanceIdentifier:a},I=new o,N=new n(w),A=await I.send(N);l=A.DBInstances[0].Endpoint.Address,u=A.DBInstances[0].DBName||A.DBInstances[0].DBInstanceIdentifier;break;default:throw new Error(`Auto Filling Twingate resource name and address is not supported for AWS resrouce type '${i}'`)}return{instanceName:u,instanceIp:l}}(d,u,y.length),m=l.instanceName,g=l.instanceIp;switch(y.length){case 1:c=m,p=g,console.log(`Using AWS resource name '${c}' as the Twingate resource name`),console.log(`Using AWS resource private IP '${p}' as the Twingate resource address`);break;case 2:c=y[1],p=g,console.log(`Using AWS resource private IP '${p}' as the Twingate resource address`);break;default:throw new Error(`tg_resource tag is in the wrong format, ${a.detail.tags.tg_resource}.`)}}if(a.detail["changed-tag-keys"].includes("tg_resource"))if("tg_resource"in a.detail.tags){let e=await async function(e,r,t,s,o,n){let a=new m(e,r),i=t;if(!t.startsWith(m.IdPrefixes.RemoteNetwork)&&(i=await a.lookupRemoteNetworkByName(t),null==i))throw new Error(`Could not find remote network: '${t}'`);let d=await a.createResource(s,o,i,n,[]);return console.log(`added resources: {'remote network': '${t}', 'resource name': '${s}', 'resource address': '${o}', 'resource id': '${d.id}'}`),d}(h,$,i,c,p,null);g=e.id;const r=a.resources;let t={ResourceARNList:r,Tags:{tg_resource_id:g}};const s=new d,o=new u(t),n=await s.send(o);0==Object.keys(n.FailedResourcesMap).length?console.log(`Added Tag 'tg_resource_id' to the AWS resource '${r}'`):console.warn(`Failed to add 'tg_resource_id' to the AWS resource '${r}'. Responds from AWS: '${JSON.stringify(n)}'`)}else console.log("tg_resource tag is removed, nothing to do.");if(c=a.detail.tags.tg_resource_id||g||c,a.detail["changed-tag-keys"].includes("tg_groups"))if("tg_groups"in a.detail.tags){let e=a.detail.tags.tg_groups.replace(/\s*\+\+\s*/g,"++").split("++");await async function(e,r,t,s){let o=new m(e,r),n=t;if(t.startsWith(m.IdPrefixes.Resource)||(n=await o.lookupResourceByName(t)),null==n)throw new Error(`Could not find resource: '${n}'`);let a=s;for(let e=0;e<a.length;e++){let r=a[e];if(!r.startsWith(m.IdPrefixes.Group)){if(r=await o.lookupGroupByName(r),null==r)throw new Error(`Could not find group: '${s}'`);a[e]=r}}let i=await o.addGroupToResource(n,a);return console.log(`added groups with IDs '${a}' to resource with ID '${n}'`),i}(h,$,c,e)}else console.log("tg_groups tag is removed, nothing to do.");if(a.detail["changed-tag-keys"].includes("tg_resource_id"))if("tg_resource_id"in a.detail.tags)console.log("tg_resource_id tag is added or modified, nothing to do.");else{if(!("tg_resource"in a.detail.tags))throw new Error("tg_resource tag is not found, can not delete resource from the Twingate");const e=a.resources,r={ResourceARNList:e,TagKeys:["tg_resource","tg_groups"]},t=new d,s=new l(r);await t.send(s);console.log(`'tg_resource' and 'tg_groups' tags has been removed from the AWS resource ${e}`);await async function(e,r,t){let s=new m(e,r),o=t;o.startsWith(m.IdPrefixes.Resource)||(o=await s.lookupResourceByName(t));let n=await s.removeResource(o);return console.log(`removed resource with ID '${o}'`),n}(h,$,c)}}async function I(e){await w(e);return{statusCode:200,body:JSON.stringify("Lambda Function Completed.")}}export{I as handler};
      Description: Lambda Function
      FunctionName: TgFunction
      Handler: handler
      MemorySize: 256
      PackageType: Zip
      Role: !GetAtt "TwingateRole.Arn"
      Runtime: nodejs16.x
      Timeout: 60
  LambdaAsyncconfig:
    Type: AWS::Lambda::EventInvokeConfig
    Properties:
      FunctionName: !Ref LambdaFunction
      MaximumRetryAttempts: 0
      Qualifier: $LATEST
  CloudWatchEventRule:
    Type: AWS::Events::Rule
    Properties:
      Description: Cloud Watch Event Rule
      EventPattern: {"source":["aws.tag"],"detail-type":["Tag Change on Resource"],"detail":{"service":["ec2", "rds", "ecs"],"changed-tag-keys":["tg_resource","tg_groups", "tg_resource_id"]}}
      Name: TwingateTagWatch
      Targets:
        - Arn: !GetAtt "LambdaFunction.Arn"
          Id: WhatIsThis
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref LambdaFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt CloudWatchEventRule.Arn